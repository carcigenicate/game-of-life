<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1491332459671">{:repl-history {:ide [], :local [&quot;(cell-states-surrounding test 1 2 2)&quot; &quot;(cell-states-surrounding test-env 1 2 2)&quot; &quot;(keyword ::test)&quot; &quot;(str ::test)&quot; &quot;(map #(if (= ::alive %) :a :d) (cell-states-surrounding test-env 1 2 2))&quot; &quot;(vec (map #(if (= ::alive %) :a :d) (cell-states-surrounding test-env 1 2 2)))&quot; &quot;(frequencies\n  (count-alive-neighbors test-env 2 2))&quot; &quot;(frequencies\n  (cell-states-surrounding test-env 1 2 2))&quot; &quot;(::alive\n  (frequencies\n    (cell-states-surrounding test-env 1 2 2)))&quot; &quot;(for [n (range 10)]\n  [(or (&lt; n 2) (&gt; n 3))\n   (&lt; 2 n 3)])&quot; &quot;()&quot; &quot;(clojure.pprint/pprint  \n  (for [n (range 10)]\n    [(or (&lt; n 2) (&gt; n 3))\n     (&lt; 2 n 3)]))&quot; &quot;(clojure.pprint/pprint  \n  (for [n (range 10)]\n    [(or (&lt; n 2) (&gt; n 3))\n     (not (&lt; 2 n 3))]))&quot; &quot;(clojure.pprint/pprint  \n  (for [n (range 10)]\n    [(or (&lt; n 2) (&gt; n 3))\n     (not (&lt;= 2 n 3))]))&quot; &quot;(cell-should-live? test-env\n                   0 1)&quot; &quot;(count-alive-neighbors test-env 0 0)&quot; &quot;(-&gt; test-env\n    (cell-states-surrounding 1 0 0)\n    (frequencies))&quot; &quot;(cell-states-surrounding test-env 2 0 0)&quot; &quot;(let [[x y] [0 0]\n      [rx ry] [1 1]])&quot; &quot;(str test-env)&quot; &quot;(println (str test-env))&quot; &quot;(let [[x y] [0 0]\n      [rx ry] [1 1]]\n  [(and (not= x rx) (not= y ry))\n   (or (= rx))])&quot; &quot;(cell-states-surrounding test-env 1 0 0)&quot; &quot;(cell-states-surrounding test-env 1 1 1)&quot; &quot;(alive-at? test-env 2 1)&quot; &quot;(clojure.pprint/pprint\n  (cell-states-surrounding test-env 1 1 1))&quot; &quot;(cell-should-live? test-env\n                   4 0)&quot; &quot;(cell-should-live? test-env\n                   3 0)&quot; &quot;(cell-should-live? test-env\n                   2 0)&quot; &quot;(cell-should-live? test-env\n                   1 0)&quot; &quot;(cell-should-live? test-env\n                   0 0)&quot; &quot;(count (:cells test-env))&quot; &quot;(clojure.pprint/pprint (:cells test-env))&quot; &quot;(env-index-of test-env\n                   1 4)&quot; &quot;((:cells test-env)\n (env-index-of test-env 2 4))&quot; &quot;((:cells test-env)\n (env-index-of test-env 1 4))&quot; &quot;(cell-should-live? test-env\n                   2 4)&quot; &quot;(cell-should-live? test-env\n                   3 4)&quot; &quot;(cell-states-surrounding test-env 3 4)&quot; &quot;(cell-states-surrounding test-env 1 3 4)&quot; &quot;(cell-states-surrounding test-env 1 0 4)&quot; &quot;(clojure.pprint/pprint\n  (cell-states-surrounding test-env 1 0 4))&quot; &quot;(fn [n] (if (nil? n) 0 n))&quot; &quot;(cell-should-live? test-env\n                   0 4)&quot; &quot;(cell-should-live? test-env\n                   1 4)&quot; &quot;(cell-should-live? test-env\n                   1 3)&quot; &quot;(cell-should-live? test-env\n                   4 3)&quot; &quot;(cell-should-live? test-env\n                   4 2)&quot; &quot;(count-alive-neighbors test-env 0 4)&quot; &quot;(count-alive-neighbors test-env 4 1)&quot; &quot;(cell-states-surrounding test-env 1 4 1)&quot; &quot;(clojure.pprint/pprint\n  (cell-states-surrounding test-env 1 4 1))&quot; &quot;(-&gt; 1\n    (or 0))&quot; &quot;(-&gt; nil\n    (or 0))&quot; &quot;(clojure.pprint/pprint\n  (cell-states-surrounding test-env 1 1 4))&quot; &quot;(clojure.pprint/pprint\n  (-&gt; test-env\n      (cell-states-surrounding 1 1 4)\n      (frequencies)\n      ::alive\n      (or 0)))&quot; &quot;(-&gt; test-env\n    (cell-states-surrounding 1 1 4)\n    (frequencies)\n    ::alive\n    (or 0))&quot; &quot;(-&gt; test-env\n    (cell-states-surrounding 1 1 4)\n    (frequencies)\n    ::alive)&quot; &quot;(-&gt; test-env\n    (cell-states-surrounding 1 1 4)\n    (frequencies))&quot; &quot;(count-alive-neighbors test-env 1 4)&quot; &quot;(count-alive-neighbors test-env 2 2)&quot; &quot;(count-alive-neighbors test-env 1 1)&quot; &quot;(count-alive-neighbors test-env 3 1)&quot; &quot;(let [env test-env]\n  (println\n    (str env)\n    (str\n      (advance-environment env))))&quot; &quot;(let [env test-env]\n  (println\n    (str env) \\newline\n    \&quot;-----\\n\&quot;\n    (str\n      (advance-environment env))))&quot; &quot;(reduce\n  (fn [env _]\n    (println (str env))\n    (advance-environment env))\n  test-env\n  (range 10))&quot; &quot;(reduce\n  (fn [env _]\n    (println (str env) \&quot;\\n----------\&quot;)\n    (advance-environment env))\n  test-env\n  (range 10))&quot; &quot;(reduce\n  (fn [env _]\n    (println (str env) \&quot;\\n----------\&quot;)\n    (advance-environment env))\n  test-env\n  (range 100))&quot; &quot;(reduce\n  (fn [env n]\n    (println n \&quot;\\n\&quot;(str env) \&quot;\\n----------\&quot;)\n    (advance-environment env))\n  test-env\n  (range 20))&quot; &quot;(reduce\n  (fn [env n]\n    (println n \&quot;\\n\&quot;(str env) \&quot;\\n----------\&quot;)\n    (advance-environment env))\n  test-env\n  (range 100))&quot; &quot;(g/new-rand-gen nil)&quot; &quot;(hash \&quot;hello\&quot;)&quot; &quot;({\\a \\b \\c\\ \\d} \\a)&quot; &quot;({\\a \\b \\c \\d} \\a)&quot; &quot;((-&gt;Game nil) \\a)&quot; &quot;((hash-map (-&gt;Game nil)) \\a)&quot; &quot;(-main [])&quot; &quot;(coords-surrounding test-env 1 2 2)&quot; &quot;(int \\k)&quot; &quot;(apply * [2 3])&quot; &quot;(println (str simple-env))&quot; &quot;(cell-states-surrounding simple-env 1 2 1)&quot; &quot;(clojure.pprint/pprint\n  (cell-states-surrounding simple-env 1 2 1))&quot; &quot;(clojure.pprint/pprint\n  (count-alive-neighbors simple-env 2 1))&quot; &quot;(frequencies [1 2 1 3 4 5 2 4 3 2 5 7 6 5 4 3 3])&quot; &quot;(apply max-key val\n  (frequencies [1 2 1 3 4 5 2 4 3 2 5 7 6 5 4 3 3]))&quot; &quot;(apply max-key\n  (frequencies [1 2 1 3 4 5 2 4 3 2 5 7 6 5 4 3 3]))&quot; &quot;(max-key - 1 2 3 4 5)&quot; &quot;(max-key + 1 2 3 4 5)&quot; &quot;(key\n  (apply max-key val\n    (frequencies [1 2 1 3 4 5 2 4 3 2 5 7 6 5 4 3 3])))&quot; &quot;cell-states-v&quot; &quot;(let [r (g/new-rand-gen 99)\n      e (random-environment [300 300] 0.5 r)]\n  (g/bench\n    (reduce advance-environment e (range 20))))&quot; &quot;(let [r (g/new-rand-gen 99)\n      e (random-environment [300 300] 0.5 r)]\n  (g/bench\n    (reduce (fn [e' _] (advance-environment e')) e (range 20))))&quot; &quot;(let [r (g/new-rand-gen 99)\n      e (random-environment [300 300] 0.5 r)]\n  (g/bench\n    (advance-environment e)))&quot; &quot;(let [r (g/new-rand-gen 99)\n      states [[0 0 0] [1 1 1] [1 2 3] [3 2 1]]\n      e (random-environment states [300 300] 0.5 r)]\n  (g/bench\n    (advance-environment e)))&quot; &quot;(g/wrap 10 0 10)&quot; &quot;(g/wrap 0 0 10)&quot; &quot;(g/wrap 0 0 11)&quot; &quot;(g/wrap 11 0 10)&quot; &quot;(q/frame-rate 20)&quot; &quot;(-main)&quot;], :remote []}}</component>
</project>